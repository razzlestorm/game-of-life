
<!doctype html>
<html>
  <head>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.8.9/brython.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.8.9/brython_stdlib.js"></script>
    <title>Game of Life!</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
  </head>
  <body onload="brython(1)">
    <h1>File Upload</h1>
    <form method="POST" action="" enctype="multipart/form-data">
      <p><input type="file" name="file"></p>
      <p><input type="submit" value="Submit"></p>
    </form>
    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
    <!-- This dropdown is populated with all uploaded files -->
    <form method="POST" action="{{ url_for('game') }}">
      <select id="filedrop" name="filedrop" method="GET" action="/">
        {% for file in files %}
        <option value= {{url_for('upload', filename=file) }}>{{file}}</option>
        {% endfor %}
      </select>
      <button type="submit">Play with this board!</button>
    </form>
    <div id="image">
      <img id="selectedImage" style="width: 128px">
    </div>
    <!-- This changes the image src based on the value of the dropdown -->
    <script>    
      $( document ).ready(function() {
      document.getElementById("selectedImage").src=document.getElementById("filedrop").value;
      });
      $( "select" ) .change(function () {    
      document.getElementById("selectedImage").src=document.getElementById("filedrop").value;  
      });  
    </script>
    <hr>
    <div id ='gboard_div'>
      <img id='gboard' src={{ gameimg }} style="display:none">
      <button id="next_button">Next</button>
    </div>

<script type="text/python">
from browser import bind, document, html
from browser.timer import request_animation_frame as raf
from browser.timer import cancel_animation_frame as caf


img = document['gboard']
document <= "width: " + str(img.naturalWidth) + " height: " + str(img.naturalHeight)
img.attrs['naturalWidth'] = int(img.naturalWidth)
img.attrs['naturalHeight'] = int(img.naturalHeight)
canvas = html.CANVAS(width=img.naturalWidth, height=img.naturalHeight)
canvas.style = {"margin-left": "auto", "margin-right": "auto", "width": "50%"}
ctx = canvas.getContext('2d')
ctx.imageSmoothingEnabled = False
world = {{ gamegrid }}


def draw(arr):
    for y in range(len(arr)):
        for x in range(len(arr[y])):
            if arr[y][x] < 127:
                ctx.fillStyle = 'rgb(0,0,0)'
            else:
                ctx.fillStyle = 'rgb(255,255,255)'
            ctx.fillRect(x, y, 1, 1)
    return ctx

def play_step(world):
    stepped_world = world.copy()
    for y in range(len(world)):
        for x in range(len(world[y])):
        
            cell = world[y][x]
            neighbor_count = 0
            # Getting neighbors
            for yy in range(-1, 2):
                for xx in range(-1, 2):
                    if yy == 0 and xx == 0:
                        continue
                
                    y_cell = y+yy
                    x_cell = x+xx
                
                    if (y_cell >= 0 and x_cell >= 0) and (y_cell < len(world) and x_cell < len(world[y])):
                        neighbor = world[y + yy][x+ xx]
                        if neighbor < 127:
                            neighbor_count += 1

            # cell is alive 
            if cell < 127 and neighbor_count < 2:
                stepped_world[y][x] = 255
            elif cell < 127 and neighbor_count > 3:
                stepped_world[y][x] = 255
            # If cell is dead
            elif cell > 127 and neighbor_count == 3:
                stepped_world[y][x] = 0
    return stepped_world


sworld = play_step(world)
draw(sworld)

document <= canvas


'''def update(i):
    global world
    stepped_world = play_step(world)
    draw(stepped_world)


document <= canvas'''

'''
boardImage = ctx.getImageData(0, 0, img.naturalWidth, img.naturalHeight)
document <= " board length: "  + str(len(boardImage.data)) + " "


def rule_checker(data, iterator, *args):
    count = 0
    for arg in args:
        if arg < 127:
            count += 1
    # check if cell is alive
    if data[iterator] < 127:
        if count in [2, 3]:
            # cell stays alive (0, 0, 0) = black
            data[iterator] = 0
            data[iterator+1] = 0
            data[iterator+2] = 0
        else:
            # cell dies
            data[iterator] = 255
            data[iterator+1] = 255
            data[iterator+2] = 255

    # check if cell is dead
    else:
        if count == 3:
            data[iterator] = 0
            data[iterator+1] = 0
            data[iterator+2] = 0
    return data

@bind("#next_button", "click")
def game(event):
    ii = 0
    while ii < len(boardImage.data):
        # NW Corner
        if ii == 0:
            E = boardImage.data[ii+4]
            S = boardImage.data[ii+(canvas.width*4)]
            SE = boardImage.data[ii+(canvas.width*4)+4]
            boardImage.data = rule_checker(boardImage.data, ii, E, S, SE)
        
        # NE Corner
        elif ii == (canvas.width*4)-4:
            W = boardImage.data[ii-4]
            SW = boardImage.data[ii+(canvas.width*4)-4]
            S = boardImage.data[ii+(canvas.width*4)]
            boardImage.data = rule_checker(boardImage.data, ii, W, SW, S)
        
        # SW Corner
        elif ii == (canvas.width*4)*(canvas.height-1):
            N = boardImage.data[ii-(canvas.width*4)]
            NE = boardImage.data[ii-(canvas.width*4)+4]
            E = boardImage.data[ii+4]
            boardImage.data = rule_checker(boardImage.data, ii, N, NE, E)
        
        # SE Corner
        elif ii == (canvas.width*4)*(canvas.height)-4:
            NW = boardImage.data[ii-(canvas.width*4)-4]
            N = boardImage.data[ii-(canvas.width*4)]
            W = boardImage.data[ii-4]
            boardImage.data = rule_checker(boardImage.data, ii, NW, N, W)

        # North Edge
        elif ii < (canvas.width*4)-4:
            E = boardImage.data[ii+4]
            W = boardImage.data[ii-4]
            SW = boardImage.data[ii+(canvas.width*4)-4]
            S = boardImage.data[ii+(canvas.width*4)]
            SE = boardImage.data[ii+(canvas.width*4)+4]
            boardImage.data = rule_checker(boardImage.data, ii, E, W, SW, S, SE)
        
                
        # South Edge
        elif (canvas.width*4)*(canvas.height-1) < ii < (canvas.width*4)*(canvas.height):
            NW = boardImage.data[ii-(canvas.width*4)-4]
            N = boardImage.data[ii-(canvas.width*4)]
            NE = boardImage.data[ii-(canvas.width*4)+4]
            W = boardImage.data[ii-4]
            E = boardImage.data[ii+4]
            boardImage.data = rule_checker(boardImage.data, ii, NW, N, NE, W, E)


        # West Edge
        elif ii % (canvas.width*4) == 0:
            N = boardImage.data[ii-(canvas.width*4)]
            NE = boardImage.data[ii-(canvas.width*4)+4]
            E = boardImage.data[ii+4]
            S = boardImage.data[ii+(canvas.width*4)]
            SE = boardImage.data[ii+(canvas.width*4)+4]
            boardImage.data = rule_checker(boardImage.data, ii, N, NE, E, S, SE)
        
        # East Edge
        elif ii % (canvas.width*4) == 396:
            NW = boardImage.data[ii-(canvas.width*4)-4]
            N = boardImage.data[ii-(canvas.width*4)]
            W = boardImage.data[ii-4]
            SW = boardImage.data[ii+(canvas.width*4)-4]
            try:
                S = boardImage.data[ii+(canvas.width*4)]
            except KeyError:
                S = boardImage.data[ii+(canvas.width*4)-1]
            boardImage.data = rule_checker(boardImage.data, ii, NW, N, W, SW, S)

        
        # Everywhere Else
        else:
            NW = boardImage.data[ii-(canvas.width*4)-4]
            N = boardImage.data[ii-(canvas.width*4)]
            NE = boardImage.data[ii-(canvas.width*4)+4]
            W = boardImage.data[ii-4]
            E = boardImage.data[ii+4]
            SW = boardImage.data[ii+(canvas.width*4)-4]
            S = boardImage.data[ii+(canvas.width*4)]
            try:
                SE = boardImage.data[ii+(canvas.width*4)+4]
            except KeyError:
                SE = boardImage.data[ii+(canvas.width*4)+3]
            boardImage.data = rule_checker(boardImage.data, ii, NW, N, NE, W, E, SW, S, SE)
        ii += 4
    ctx.putImageData(boardImage, 0, 0)
    document <= canvas'''


#step forward, then draw with html canvas, https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D (maybe getImageData)
# https://stackoverflow.com/questions/51569444/check-cell-color-in-table-in-canvas
# https://stackoverflow.com/questions/12992681/html-5-canvas-get-color-of-an-image-and-then-change-the-pixels-with-that-color
</script>


  </body>
</html>